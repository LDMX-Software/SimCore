#include "catch.hpp"

//----------//
//   LDMX   //
//----------//
#include "Framework/Parameters.h"
#include "Framework/Logger.h"
#include "SimCore/G4eDarkBremsstrahlung.h"
#include "SimCore/G4APrime.h"

namespace ldmx { 
namespace test { 
namespace SimCore {

/**
 * @func Test Xsec Calculation
 * How we test the cross sections
 * loop through the map of correct cross sections and make sure they are calculated correctly.
 *
 * @param[in] the_cache Cache to test
 * @param[in] energy_to_xsec map from energy [MeV] to correct xsec for the given element
 * @param[in] element atomic mass [amu]
 * @param[in] element atomic number
 */
void test_calculation( ldmx::ElementXsecCache& the_cache, std::map<double,double> energy_to_xsec, double A, double Z ) {
    for ( auto const& [ energy , xsec ] : energy_to_xsec ) {
        G4double actual_xsec;
        REQUIRE_NOTHROW( actual_xsec = the_cache.get( energy*MeV , A , Z ) );
        CHECK(actual_xsec/CLHEP::picobarn == Approx(xsec));
    }
}

} //SimCore
} //test
} //ldmx

/**
 * The executable main for printing out the table.
 *
 */
TEST_CASE( "Custom Geant4 Dark Brem Process" , "[SimCore][signal][functionality]" ) {

    //open logging but turn everything off
    ldmx::logging::open( ldmx::logging::level::fatal , ldmx::logging::level::fatal , "" );

    double ap_mass = 10.; //MeV - A' mass to use for functionality testing
    G4APrime* ap = G4APrime::APrime(ap_mass);

    ldmx::Parameters process;
    process.addParameter( "ap_mass"            , ap_mass );
    process.addParameter( "enable"             , true );
    process.addParameter( "only_one_per_event" , false );
    process.addParameter( "cache_xsec"         , true );

    SECTION( "Vertex Library Model" ) {

        ldmx::Parameters model;
        model.addParameter( "name"         , std::string("vertex_library") );
        model.addParameter( "library_path" , std::string("${DB_VERTEX_LIB_INSTALL}/mA.0.01") ); //need to align with ap_mass
        model.addParameter( "method"       , std::string("forward_only") );
        model.addParameter( "threshold"    , 2.0 );
        model.addParameter( "epsilon"      , 0.01 );

        process.addParameter( "model" , model );

        ldmx::G4eDarkBremsstrahlung db_process(process);
    
        SECTION( "Xsec Calculation" ) {

            //for this model, we calculated common cross sections in the constructor
            //  and cached them for later use, so we just get the cache here
            ldmx::ElementXsecCache& the_cache = db_process.getCache();

            /**
             * map of correct cross sections
             *
             * These are calculated manually following
             * what we think the cross section calculation in the model
             * is doing.
             *
             * Key: incident electron energy in MeV
             * Val: cross section output in pb
             */
            std::map<double,double> correct_xsec_10MeVap_silicon = {
                { 4000. , 2488070.647587474 },
                { 3800. , 2462515.906436039 },
                { 3500. , 2420086.00481791  }, 
                { 3000. , 2336055.85759004  },
                { 1000. , 0.                } //below threshold should be zero
            };

            ldmx::test::SimCore::test_calculation( the_cache , correct_xsec_10MeVap_silicon , 28.085 , 14. );

            std::map<double,double> correct_xsec_10MeVap_tungsten = {
                { 4000. , 61899940.025823   }, 
                { 3800. , 61406859.20150866 }, 
                { 3500. , 60576693.40954262 }, 
                { 3000. , 58887928.38813038 },
                { 1000. , 0.                } //below threshold should be zero
            };

            ldmx::test::SimCore::test_calculation( the_cache , correct_xsec_10MeVap_tungsten , 183.84 , 74. );
        }
    
        SECTION( "Creating Secondaries" ) {

            //particle_change = db_process.PostStepDoIt( track , step );
    
        }

    }

    ldmx::logging::close();
}

