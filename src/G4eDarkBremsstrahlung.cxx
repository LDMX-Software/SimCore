/**
 * @file G4eDarkBremsstrahlung.cxx
 * @brief Class providing the Dark Bremsstrahlung process class.
 * @author Michael Revering, University of Minnesota
 * @author Tom Eichlersmith, University of Minnesota
 */

#include "SimCore/G4eDarkBremsstrahlung.h"
#include "SimCore/G4APrime.h"
#include "SimCore/DarkBremVertexLibraryModel.h"

#include "Event/RunHeader.h"

#include "G4Electron.hh" //for electron definition
#include "G4ProcessTable.hh" //for deactivating dark brem process
#include "G4ProcessType.hh" //for type of process
#include "G4RunManager.hh" //for VerboseLevel
#include "G4EventManager.hh" //for EventID number

namespace ldmx {

    const std::string G4eDarkBremsstrahlung::PROCESS_NAME = "eDarkBrem";

    G4eDarkBremsstrahlung::G4eDarkBremsstrahlung(const Parameters& params)
        : G4VDiscreteProcess(G4eDarkBremsstrahlung::PROCESS_NAME,fElectromagnetic) { 
        // we need to pretend to be an EM process so the biasing framework recognizes us
        SetProcessSubType(63); //needs to be different from the other Em Subtypes
    
        only_one_per_event_ = params.getParameter<bool>("only_one_per_event");
        cache_xsec_         = params.getParameter<bool>("cache_xsec");
        ap_mass_            = params.getParameter<double>("ap_mass");

        auto model{params.getParameter<Parameters>("model")};
        auto model_name{model.getParameter<std::string>("name")};
        if ( model_name == "vertex_library" ) {
            theModel_ = std::make_unique<DarkBremVertexLibraryModel>(model);
        } else {
            EXCEPTION_RAISE("DarkBremModel","Model named '"+model_name+"' is not known.");
        }
    }
    
    G4bool G4eDarkBremsstrahlung::IsApplicable(const G4ParticleDefinition& p) {
        return &p == G4Electron::Electron();
    }
    
    void G4eDarkBremsstrahlung::PrintInfo() {
        G4cout << " Only One Per Event               : " << only_one_per_event_ << G4endl;
        G4cout << " A' Mass [MeV]                    : " << ap_mass_ << G4endl;
        theModel_->PrintInfo();
    }

    void G4eDarkBremsstrahlung::RecordConfig(RunHeader& h) const {
        h.setIntParameter( "Only One DB Per Event" , only_one_per_event_ );
        h.setFloatParameter( "A' Mass [MeV]" , ap_mass_ );
        theModel_->RecordConfig(h);
    }
    
    G4VParticleChange* G4eDarkBremsstrahlung::PostStepDoIt(const G4Track& track, const G4Step& step) {

        // Debugging Purposes: Check if track we get is an electron
        if (not IsApplicable(*track.GetParticleDefinition()))
            EXCEPTION_RAISE("DBBadTrack","Dark brem process receieved a track that isn't applicable.");

        /*
         * Geant4 has decided that it is our time to interact,
         * so we are going to change the particle
         */
        ldmx_log(info)
            << "(" << G4EventManager::GetEventManager()->GetConstCurrentEvent()->GetEventID() << ") "
            << "A dark brem occurred!";

        if ( only_one_per_event_ ) {
            //Deactivate the process after one dark brem if we restrict ourselves to only one per event.
            //If this is in the stepping action instead, more than one brem can occur within each step.
            //Reactivated in RunManager::TerminateOneEvent
            //Both biased and unbiased process could be in the run (but not at the same time),
            //  so we turn off both while silencing the warnings from the process table.
            std::vector<G4String> db_process_name_options = {
                    "biasWrapper("+PROCESS_NAME+")",
                    PROCESS_NAME
            };
            G4ProcessTable* ptable = G4ProcessTable::GetProcessTable();
            G4int verbosity = ptable->GetVerboseLevel();
            ptable->SetVerboseLevel(0);
            for ( auto const& name : db_process_name_options ) ptable->SetProcessActivation(name,false);
            ptable->SetVerboseLevel(verbosity);
        }

        aParticleChange.Initialize(track);

        theModel_->GenerateChange( aParticleChange , track , step );

        /* 
         * Parent class has some internal counters that need to be reset,
         * so we call it before returning. It will return our shared
         * protected member variable aParticleChange that we have been modifying
         */
        return G4VDiscreteProcess::PostStepDoIt(track,step);
    }

    G4double G4eDarkBremsstrahlung::GetMeanFreePath(const G4Track& track, G4double, G4ForceCondition*) {

        /**
         * The cache of computed cross sections based on element
         *
         * The keys in this map are generated by the lambda function below.
         *
         * Key: unique integer ID for the inputs to the model's cross section computer.
         * Val: value of the cross section output by the model
         */
        static std::map<unsigned int,G4double> cache_element_xsec;

        /**
         * Compute a key for the cache map
         * Generating a unique key _after_ making the energy [MeV] an integer.
         * The atomic mass (A) and charge (Z) are given by Geant4 as doubles as well,
         * so I cast them to integers before computing the key.
         *
         * This is what you would edit if you want a more/less find-grained cache
         * of Xsecs. Right now, since the internal unit of energy in Geant4 is MeV,
         * the cache is binned at the 1MeV scale.
         */
        static auto const computeCacheKey = [](G4double energy, G4double A, G4double Z) -> unsigned int {
            int energyKey = int(energy); //will be between 0 and 4000, pick 30000 for safety
            int AKey      = int(A); //will be between roughly 1 and 400, pick 1000 for safety
            int ZKey      = int(Z);
            return (energyKey*30000+AKey)*1000 + ZKey;
        };

        //won't happen if it isn't applicable
        if (not IsApplicable(*track.GetParticleDefinition())) return DBL_MAX;

        G4Material* materialWeAreIn = track.GetMaterial();
        const G4ElementVector* theElementVector = materialWeAreIn->GetElementVector();
        const G4double* NbOfAtomsPerVolume = materialWeAreIn->GetVecNbOfAtomsPerVolume();
     
        G4double SIGMA = 0;
        for ( size_t i=0 ; i < materialWeAreIn->GetNumberOfElements() ; i++ ) {
            G4double AtomicZ = (*theElementVector)[i]->GetZ();
            G4double AtomicA = (*theElementVector)[i]->GetA()/(g/mole);
            G4double energy = track.GetDynamicParticle()->GetKineticEnergy();

            G4double element_xsec;

            unsigned int cache_key = computeCacheKey(energy,AtomicA,AtomicZ);
            bool need_to_calculate_xsec = true;
            if (cache_xsec_) {
                if (cache_element_xsec.find(cache_key) != cache_element_xsec.end()) {
                    element_xsec = cache_element_xsec.at(cache_key);
                    need_to_calculate_xsec = false;
                } //found it in the map
            } //should we cache

            if (need_to_calculate_xsec) {
                //xsec hasn't been set yet -> either no caching or not found in cache
                // ==> calculate it
                element_xsec = theModel_->ComputeCrossSectionPerAtom(energy,AtomicA,AtomicZ);
                //put it into the cache
                if (cache_xsec_) cache_element_xsec[cache_key] = element_xsec;
            }

            SIGMA += NbOfAtomsPerVolume[i]*element_xsec;        
        }

        return SIGMA > DBL_MIN ? 1./SIGMA : DBL_MAX;
    }
}
